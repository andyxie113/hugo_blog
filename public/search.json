[{"categories":["centos7","mysql","编译"],"content":"1.软件准备 1 2 3  cd /opt/soft wget https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.51.tar.gz tar xf mysql-5.6.51.tar.gz   2.创建用户 1 2  groupadd -g 550 mysql useradd -g mysql -u 550 mysql   3.安装依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  yum install cmake autoconf wget gcc-c++ gcc ncurses-devel openssl openssl-devel -y cd mysql-5.6.51/ cmake \\ -DCMAKE_INSTALL_PREFIX=/opt/mysql \\ -DMYSQL_DATADIR=/opt/data/mysql \\ -DSYSCONFDIR=/etc \\ -DWITH_MYISAM_STORAGE_ENGINE=1 \\ -DWITH_INNOBASE_STORAGE_ENGINE=1 \\ -DWITH_MEMORY_STORAGE_ENGINE=1 \\ -DMYSQL_UNIX_ADDR=/var/run/mysql/mysqld.sock \\ -DMYSQL_TCP_PORT=3306 \\ -DENABLED_LOCAL_INFILE=1 \\ -DWITH_PARTITION_STORAGE_ENGINE=1 \\ -DENABLE_DOWNLOADS=1 \\ -DEXTRA_CHARSETS=all \\ -DDEFAULT_CHARSET=utf8 \\ -DDEFAULT_COLLATION=utf8_general_ci   ​\t执行完cmake之后、执行make和make install\n参数详解： 1 2 3 4 5 6 7 8 9 10 11 12 13  -DCMAKE_INSTALL_PREFIX=/opt/mysql \\  #安装路径 -DMYSQL_DATADIR=/opt/data/mysql \\  #数据文件存放地 -DSYSCONFDIR=/etc \\  #配置文件my.cnf存放地  -DWITH_MYISAM_STORAGE_ENGINE=1 \\  #支持MyIASM引擎  -DWITH_INNOBASE_STORAGE_ENGINE=1 \\  #支持InnoDB引擎  -DWITH_MEMORY_STORAGE_ENGINE=1 \\  #支持Memory引擎  -DMYSQL_UNIX_ADDR=/var/run/mysql/mysqld.sock \\  #连接数据库socket路径  -DMYSQL_TCP_PORT=3306 \\  #数据库端口号  -DENABLED_LOCAL_INFILE=1 \\  #允许从本地导入数据  -DWITH_PARTITION_STORAGE_ENGINE=1 \\ #安装支持数据库分区  -DEXTRA_CHARSETS=all \\  #安装所有的字符集  -DDEFAULT_CHARSET=utf8 \\  #默认字符  -DDEFAULT_COLLATION=utf8_general_ci   4.数据库初始化 ​\t安装目录授权\n1 2  chown -R mysql.mysql /opt/mysql/ chown -R mysql.mysql /opt/data/mysql/   ​\t修改my.cnf文件\n[mysql] socket=/opt/mysql/mysqld.sock default-character-set=utf8 [mysqld] skip-grant-tables explicit_defaults_for_timestamp=true skip-name-resolve port = 3306 socket=/opt/mysql/mysqld.sock basedir=/opt/mysql datadir=/opt/data/mysql max_connections = 2000 default-storage-engine=INNODB lower_case_table_names=1 max_allowed_packet=16M log-error=/opt/mysql/logs/mysql.log pid-file=/opt/mysql/mysql.pid !includedir /etc/my.cnf.d ​\t开始初始化\n1  ./scripts/mysql_install_db --user=mysql --datadir=/opt/data/mysql --no-defaults   ​\t启动mysql\n1 2 3 4  #拷贝启动文件 cp ./support-files/mysql.server /etc/init.d/mysql chmod +x /etc/init.d/mysql /etc/init.d/mysql start   ​\t设置mysql环境变量\n1 2 3  vim /etc/profile.d/mysql.sh export PATH=/usr/local/mysql/bin:$PATH source /etc/profile   ​\t修改数据库密码\n1 2 3 4  mysqlusemysql;updateusersetpassword=password(\"newpasswd\")whereuser='root'andhost='localhost';flushprivileges;  ","description":"CentOS7编译安装MySQL5.6","tags":["centos7","mysql","编译"],"title":"CentOS7编译安装MySQL5.6","uri":"/posts/centos7%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85mysql5.6/"},{"categories":["centos7","redis","编译"],"content":"​\tCentos7 Redis5安装及配置，自启动配置\n1.解压、编译、安装reids ​\t官网地址\n1 2 3 4 5 6 7 8 9 10 11 12  #获取安装包 cd /opt/soft wget https://download.redis.io/releases/redis-5.0.14.tar.gz #解压 tar xf redis-5.0.14.tar.gz #安装依赖 yum -y install gcc automake autoconf libtool make #编译 cd redis-5.0.14/ make #编译安装 make install PREFIX=/opt/redis5   2.Redis配置文件修改 ​\t创建redis的data目录，存放redis配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  mkdir -p /opt/data/redis #复制redis.conf配置文件 cp redis.conf /opt/redis5/bin/ cd /opt/redis5/bin/ #配置文件设置 vim redis.conf daemonize yes\t--开启守护进程模式 bind 127.0.0.1\t--注释bind 127.0.0.1这行，否则只能本地连接redis protected-mode no\t--关闭保护模式，开启远程连接 pidfile /opt/data/redis/redis.pid logfile \"redis.log\" dbfilename dump.rdb dir /opt/data/redis requirepass foobared\t--在这行下面增加一行“requirepass password”来开启Redis密码认证   3.Redis启动 1  /opt/redis5/bin/redis-server /opt/redis5/bin/redis.conf   4.Centos7设置Redis开机启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #创建服务文件 vi /etc/systemd/system/redis.service [Unit] #Description:描述服务 Description=Redis #After:描述服务类别  After=network.target #服务运行参数的设置  [Service] #Type=forking是后台运行的形式  Type=forking #ExecStart为服务的具体运行命令，路径必须是绝对路径  ExecStart=/opt/redis5/bin/redis-server /opt/redis5/bin/redis.conf #ExecReload为重启命令 ，路径必须是绝对路径  ExecReload=/opt/redis5/bin/redis-server -s reload #ExecStop为停止命令 ，路径必须是绝对路径  ExecStop=/opt/redis5/bin/redis-server -s stop #PrivateTmp=True表示给服务分配独立的临时空间  PrivateTmp=true #运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3 [Install] WantedBy=multi-user.target #重载系统服务 systemctl daemon-reload #命令 systemctl start redis.service #启动redis服务  systemctl enable redis.service #设置开机自启动  systemctl disable redis.service #停止开机自启动  systemctl status redis.service #查看服务当前状态  systemctl restart redis.service　#重新启动服务  systemctl list-units --type=service #查看所有已启动的服务    ","description":"CentOS7编译安装Redis5.0","tags":["centos7","redis","编译"],"title":"CentOS7编译安装Redis5.0","uri":"/posts/centos7%E5%AE%89%E8%A3%85redis5/"},{"categories":["centos7","go","nsq"],"content":"nsq简介 实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。它具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征  依赖 ​\tnsq使用go语言编写，需要安装go的环境。本文选用最新版go语言\ngo环境安装 获取包 1 2 3 4  #下载包 wget https://golang.google.cn/dl/go1.18.2.linux-amd64.tar.gz #解压go包到/usr/local tar -zxf go1.18.2.linux-amd64.tar.gz -C /usr/local   配置go环境变量 1 2 3 4 5 6 7 8 9  vim /etc/profile export GOROOT=/usr/local/go export PATH=$GOPATH/bin:$GOROOT/bin:$PATH #环境变量生效 source /etc/profile #和下面的命令等价 . /etc/profile #和上面的命令等价 #检查验证 go env go version   nsq安装 获取安装包 1 2 3 4  wget https://s3.amazonaws.com/bitly-downloads/nsq/nsq-1.2.0.linux-amd64.go1.12.9.tar.gz tar -zxvf nsq-1.2.0.linux-amd64.go1.12.9.tar.gz -C /usr/local/ cd /usr/local mv nsq-1.2.0.linux-amd64.go1.12.9/ nsq-1.2   配置nsqlookupd服务 1 2 3 4 5 6 7 8 9 10 11  vi /usr/lib/systemd/system/nsqlookupd.service [Unit] Description=nsqlookup daemon Service After=network.target remote-fs.target nss-lookup.target [Service] #Type= PrivateTmp=yes ExecStart=/usr/local/nsq-1.2/bin/nsqlookupd Restart=on-abort [Install] WantedBy=multi-user.target   配置nsqd服务 1 2 3 4 5 6 7 8 9 10 11 12  vi /usr/lib/systemd/system/nsqd.service [Unit] Description=nsqd daemon Service After=network.target remote-fs.target nss-lookup.target [Service] #Type= PrivateTmp=yes ExecStart=/usr/local/nsq-1.2/bin/nsqd --lookupd-tcp-address=0.0.0.0:4160 --tcp-address=0.0.0.0:4150 --http-address=0.0.0.0:4151 --broadcast-address=127.0.0.1 #修改broadcast-address Restart=on-abort [Install] WantedBy=multi-user.target   配置nsqadmin服务 1 2 3 4 5 6 7 8 9 10 11  vi /usr/lib/systemd/system/nsqadmin.service [Unit] Description=nsqadmin daemon Service After=network.target remote-fs.target nss-lookup.target [Service] #Type= PrivateTmp=yes ExecStart=/usr/local/nsq-1.2/bin/nsqadmin --lookupd-http-address=127.0.0.1:4161 Restart=on-abort [Install] WantedBy=multi-user.target   启动nsq 1 2 3  systemctl start nsqd systemctl start nsqadmin systemctl start nsqlookupd   nsq特性  支持无 SPOF 的分布式拓扑 水平扩展(没有中间件，无缝地添加更多的节点到集群) 低延迟消息传递 (性能) 结合负载均衡和多播消息路由风格 擅长面向流媒体(高通量)和工作(低吞吐量)工作负载 主要是内存中(除了高水位线消息透明地保存在磁盘上) 运行时发现消费者找到生产者服务(nsqlookupd) 传输层安全性 (TLS) 数据格式不可知 一些依赖项(容易部署)和健全的，有界，默认配置 任何语言都有简单 TCP 协议支持客户端库 HTTP 接口统计、管理行为和生产者(不需要客户端库发布) 为实时检测集成了 statsd 健壮的集群管理界面 (nsqadmin)  NSQ组件 NSQD ​\tnsqd 是一个守护进程，负责接收，排队，投递消息给客户端。也就是说这个服务是干活的。它可以独立运行，不过通常它是由 nsqlookupd 实例所在集群配置的。 nsqd特性如下：\n 对订阅了同一个topic，同一个channel的消费者使用负载均衡策略（不是轮询） 只要channel存在，即使没有该channel的消费者，也会将生产者的message缓存到队列中（注意消息的过期处理） 保证队列中的message至少会被消费一次，即使nsqd退出，也会将队列中的消息暂存磁盘上(结束进程等意外情况除外) 限定内存占用，能够配置nsqd中每个channel队列在内存中缓存的message数量，一旦超出，message将被缓存到磁盘中 topic，channel一旦建立，将会一直存在，要及时在管理台或者用代码清除无效的topic和channel，避免资源的浪费  NSQLOOKUPD ​\tnsqlookupd 是守护进程负责管理拓扑信息。客户端通过查询 nsqlookupd 来发现指定话题（topic）的生产者，并且 nsqd 节点广播话题（topic）和通道（channel）信息。也就是说nsqlookupd是管理者。 nsqlookupd 特性：\n 唯一性，在一个Nsq服务中只有一个nsqlookupd服务。当然也可以在集群中部署多个nsqlookupd，但它们之间是没有关联的. 去中心化，即使nsqlookupd崩溃，也会不影响正在运行的nsqd服务 充当nsqd和naqadmin信息交互的中间件 提供一个http查询服务，给客户端定时更新nsqd的地址目录  NSQADMIN ​\tnsqadmin是web管理界面，用来汇集集群的实时统计，并执行不同的管理任务。也就是说nsqadmin就是我们在浏览器中看到的那个。 nsqadmin特性如下：\n 提供一个对topic和channel统一管理的操作界面以及各种实时监控数据的展示，界面设计的很简洁，操作也很简单 展示所有message的数量 能够在后台创建topic和channel nsqadmin的所有功能都必须依赖于nsqlookupd，nsqadmin只是向nsqlookupd传递用户作并展示来自nsqlokupd的数据  ","description":"go环境安装，nsq安装，nsq简介，nsq组件介绍","tags":["centos7","go","nsq"],"title":"CentOS7安装NSQ","uri":"/posts/centos7%E5%AE%89%E8%A3%85nsq/"},{"categories":["navicat","工具","激活工具"],"content":"1.安装 ​\t打开官网:\nhttps://navicat.com.cn/download/navicat-premium\n2.激活 支持Windows和Mac!\nwindows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  @echo off echo Delete HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatPremium\\Registration[version and language] for /f %%i in ('\"REG QUERY \"HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatPremium\" /s | findstr /L Registration\"') do ( reg delete %%i /va /f ) echo. echo Delete Info folder under HKEY_CURRENT_USER\\Software\\Classes\\CLSID for /f %%i in ('\"REG QUERY \"HKEY_CURRENT_USER\\Software\\Classes\\CLSID\" /s | findstr /E Info\"') do ( reg delete %%i /va /f ) echo. echo Finish pause   mac:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  @echo off echo Delete HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatPremium\\Registration[version and language] for /f %%i in ('\"REG QUERY \"HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatPremium\" /s | findstr /L Registration\"') do ( reg delete %%i /va /f ) echo. echo Delete Info folder under HKEY_CURRENT_USER\\Software\\Classes\\CLSID for /f %%i in ('\"REG QUERY \"HKEY_CURRENT_USER\\Software\\Classes\\CLSID\" /s | findstr /E Info\"') do ( reg delete %%i /va /f ) echo. echo Finish pause   3.其他路子 ​\t教师和学生申请！\nhttps://www.navicat.com.cn/sponsorship/education/student\n","description":"Navicat激活","tags":["navicat","工具","激活工具"],"title":"Navicat激活","uri":"/posts/navicat%E6%BF%80%E6%B4%BB/"},{"categories":["rocketmq"],"content":"​\tRocketMQ使用者反馈在消息发送过程中偶尔会出现如下错误信息：\n [REJECTREQUEST]system busy, start flow control for a while [PC_SYNCHRONIZED]broker busy, start flow control for a while [PCBUSY_CLEAN_QUEUE]broker busy, start flow control for a while, period in queue: %sms, size of queue: %d too many requests and system thread pool busy, RejectedExecutionException [TIMEOUT_CLEAN_QUEUE]broker busy  原因： ​\t消息发送时抛出system busy、broker busy错误，其本质是系统的PageCache繁忙，通俗一点讲就是向PageCache追加消息时，单个消息发送占用的时间超过1s了。\n  osPageCacheBusyTimeOutMills + broker busy\npagecache压力较大\n判断pagecache是否忙的依据就是在写入消息时，在向内存追加消息时加锁的时间，默认的判断标准是加锁时间超过1s，就认为是pagecache压力大，向客户端抛出相关的错误日志。\n优化: 理论上可以把osPageCacheBusyTimeOutMills的值调大一点，但是不推荐，特别是对时效敏感的系统\n  sendThreadPoolQueueCapacity + system busy\n发送线程池挤压的拒绝策略\n简单说所有到达Broker的请求会被转入到一个线程继续，这个线程的长度由sendThreadPoolQueueCapacity决定，默认长度为10000，超过就报system busy\n优化：理论上可以增加该参数防止报异常，但是不建议，治标不治本\n  brokerFastFailureEnable + broker busy\nBroker端快速失败策略\nbrokerFastFailureEnable默认为true，表示开启快速失败策略\n如果brokerFastFailureEnable=true,当如果发现Broker服务器的PageCache繁忙，如果发现sendThreadPoolQueue队列中不为空，表示还有排队的发送请求在排队等待执行，则直接结束等待，返回broker busy，\n  优化方向： 方向一：   当Broker服务器自身比较忙的时候，快速失败，并且在接下来的一段时间内会规避该Broker，这样该Broker恢复提供了时间保证，Broker本身的架构是支持分布式水平扩容的，增加Topic的队列数，降低单台Broker服务器的负载，从而避免出现PageCache。\n  与之扩容对应的，也可以通过对原有Broker进行升配，例如增加内存、把机械盘换成SSD，但这种情况，通常需要重启Broekr服务器，没有扩容来的方便\n  方向二： ​\t在broker配置文件中将transientStorePoolEnable设置为true。\n  依据： 启用“读写”分离，消息发送时消息先追加到DirectByteBuffer(堆外内存)中，然后在异步刷盘机制下，会将DirectByteBuffer中的内容提交到PageCache，然后刷写到磁盘。消息拉取时，直接从PageCache中拉取，实现了读写分离，减轻了PageCaceh的压力，能从根本上解决该问题。\n  缺点： 会增加数据丢失的可能性，如果Broker JVM进程异常退出，提交到PageCache中的消息是不会丢失的，但存在堆外内存(DirectByteBuffer)中但还未提交到PageCache中的这部分消息，将会丢失。但通常情况下，RocketMQ进程退出的可能性不大。\n  ","description":"消息发送过程中偶尔会出现错误信息","tags":["rocketmq"],"title":"RocketMQ出现system busy、broker busy原因分析与解决","uri":"/posts/rocketmq_1/"}]
